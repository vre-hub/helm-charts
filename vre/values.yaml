
jupyterhub:
  enabled: true

  proxy:
    service:
      type: ClusterIP
  hub:
    service:
      type: ClusterIP
    # network policy needs to be modified to allow access to the Rucio server
    # (disabling it for now as a workaround, see also the ones for singeluser and proxy below)
    networkPolicy:
      enabled: false
    db:
      #upgrade: true
      type: postgres # passed as s secret (dbconnect string) from the jhub-vre-db secret
      url: #TODO: set through secret
    
    config:
      JupyterHub:
        authenticator_class: "generic-oauth"
      RucioAuthenticator:
        # client_id: "" # TODO: set through secret
        # client_secret: "" # TODO: set through secret
        authorize_url: https://iam-escape.cloud.cnaf.infn.it/authorize
        token_url: https://iam-escape.cloud.cnaf.infn.it/token
        userdata_url: https://iam-escape.cloud.cnaf.infn.it/userinfo
        oauth_callback_url: https://jhub-vre.obsuks4.unige.ch/hub/oauth_callback
        username_key: preferred_username
        enable_auth_state: true
        allow_all: true
        scope:
          - openid
          - profile
          - email

    extraConfig:

      token-exchange: |
        import pprint
        import os
        import warnings
        import requests
        from oauthenticator.generic import GenericOAuthenticator

        # custom authenticator to enable auth_state and get access token to set as env var for rucio extension
        class RucioAuthenticator(GenericOAuthenticator):
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.enable_auth_state = True

            def exchange_token(self, token):
                params = {
                    'client_id': self.client_id,
                    'client_secret': self.client_secret,
                    'grant_type': 'urn:ietf:params:oauth:grant-type:token-exchange',
                    'subject_token_type': 'urn:ietf:params:oauth:token-type:access_token',
                    'subject_token': token,
                    'scope': 'openid profile',
                    'audience': 'rucio'
                }
                response = requests.post(self.token_url, data=params)
                print("EXCHANGE TOKEN for params", params)
                print(response.json())
                rucio_token = response.json()['access_token']

                return rucio_token
                
            async def pre_spawn_start(self, user, spawner):
                auth_state = await user.get_auth_state()
                #print("AUTH_state")
                #pprint.pprint(auth_state)
                if not auth_state:
                    # user has no auth state
                    return False
                
                # define token environment variable from auth_state
                spawner.environment['RUCIO_ACCESS_TOKEN'] = self.exchange_token(auth_state['access_token'])
                spawner.environment['EOS_ACCESS_TOKEN'] = auth_state['access_token']
        
        # set the above authenticator as the default
        c.JupyterHub.authenticator_class = RucioAuthenticator

        # enable authentication state
        c.GenericOAuthenticator.enable_auth_state = True
      
  singleuser:
    # TODO: revert!
    cloudMetadata:
      blockWithIptables: false 
    defaultUrl: "/lab"
    # The liefcycle hooks are used to create the Rucio configuration file,
    # and the token file by copying the REFRESH_TOKEN from the environment variable to the token file.
    startTimeout: 1200
    lifecycleHooks:
      postStart:
        exec:
          command:
            - "sh"
            - "-c"
            - |
              if [ "${SKIP_POSTSTART_HOOK}" = "true" ]; then
                echo "hello world";
              else
                mkdir -p /certs /tmp;
                echo -n $RUCIO_ACCESS_TOKEN > /tmp/rucio_oauth.token;
                echo -n "oauth2:${EOS_ACCESS_TOKEN}:iam-escape.cloud.cnaf.infn.it/userinfo" > /tmp/eos_oauth.token;
                chmod 0600 /tmp/eos_oauth.token;
                mkdir -p /opt/rucio/etc;
                echo "[client]" >> /opt/rucio/etc/rucio.cfg;
                echo "rucio_host = https://vre-rucio.cern.ch" >> /opt/rucio/etc/rucio.cfg;
                echo "auth_host = https://vre-rucio-auth.cern.ch" >> /opt/rucio/etc/rucio.cfg;
                echo "ca_cert = /certs/rucio_ca.pem" >> /opt/rucio/etc/rucio.cfg;
                echo "account = $JUPYTERHUB_USER" >> /opt/rucio/etc/rucio.cfg;
                echo "auth_type = oidc" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_audience = rucio" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_polling = true" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_issuer = escape" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_scope = openid profile offline_access" >> /opt/rucio/etc/rucio.cfg;
                echo "auth_token_file_path = /tmp/rucio_oauth.token" >> /opt/rucio/etc/rucio.cfg;
              fi;
              
    networkPolicy:
      enabled: false
    storage:
      # type: static
      # static:
        # pvcName: jhub-vre-singleuser-preprovisioned-manila-pvc # manually added an existing share (refer to jhub-storage.yaml)
      extraVolumes: []
        # - name: cvmfs-vre
        #   persistentVolumeClaim:
        #     claimName: cvmfs-vre-pvc
        # - name: eospilot-eulake # mounts the EOS RSE needed for the Rucio JupiterLab extension
        #   hostPath:
        #     # path: /var/eos/eulake # This is pointing to /eos/pilot/eulake/escape/data, defined on the configmap/eos-csi-dir-etc-eo  
        #     path: /var/eos/pilot
        # - name: eos-atlas
        #   hostPath:
        #     path: /var/eos/atlas
      extraVolumeMounts: []
        # - name: cvmfs-vre
        #   mountPath: /cvmfs
        #   # CVMFS automount volumes must be mounted with HostToContainer mount propagation.
        #   mountPropagation: HostToContainer
        # - name: eospilot-eulake # mounts the EOS RSE needed for the Rucio JupiterLab extension
        #   mountPath: /eos/eulake
        #   mountPropagation: HostToContainer
        #   readOnly: true 
        # - name: eos-atlas
        #   mountPath: /eos/atlas
        #   mountPropagation: HostToContainer
        #   readOnly: true
    image:
      name: ghcr.io/vre-hub/vre-singleuser-py311
      tag: sha-281055c
      pullPolicy: Always


    profileList:
      - display_name: "Default environment"
        description: "Based on a scipy notebook environment with a python-3.11 kernel, the rucio jupyterlab extension and the reana client installed."
        default: true

    # nodeSelector: 
    #   jupyter: singleuser
    # extraTolerations:
    #   - key: jupyter
    #     operator: Equal
    #     value: singleuser
    #     effect: NoSchedule
    # memory:
    #   limit: 3.5G #4G
    #   guarantee: 3G #2G

    cmd: null
    extraEnv:
  #     JUPYTERHUB_SINGLEUSER_APP: "notebook.notebookapp.NotebookApp"
      RUCIO_MODE: "replica"
      RUCIO_WILDCARD_ENABLED: "1"
      RUCIO_BASE_URL: "https://vre-rucio.cern.ch"
      RUCIO_AUTH_URL: "https://vre-rucio-auth.cern.ch"
      RUCIO_WEBUI_URL: "https://vre-rucio-ui.cern.ch"
      RUCIO_DISPLAY_NAME: "RUCIO - CERN VRE"
      RUCIO_NAME: "vre-rucio.cern.ch"
      RUCIO_SITE_NAME: "CERN"
      RUCIO_OIDC_AUTH: "env"
      RUCIO_OIDC_ENV_NAME: "RUCIO_ACCESS_TOKEN"
      RUCIO_DEFAULT_AUTH_TYPE: "oidc"
      RUCIO_OAUTH_ID: "rucio"
      RUCIO_DEFAULT_INSTANCE: "vre-rucio.cern.ch"
      RUCIO_DESTINATION_RSE: "CERN-EOSPILOT"
      RUCIO_RSE_MOUNT_PATH: "/eos/eulake"
      RUCIO_PATH_BEGINS_AT: "5" # because we are need to substitute /eos/pilot/eulake/escape/data with /eos/eulake
      RUCIO_CA_CERT: "/certs/rucio_ca.pem"
      OAUTH2_TOKEN: "FILE:/tmp/eos_oauth.token"

    # extraFiles:
    #   jupyter_notebook_config.json:
    #     mountPath: /etc/jupyter/jupyter_notebook_config.json
    #     data:
    #       MappingKMappingKernelManager:
    #         cull_idle_timeout: 3600
    #         cull_interval: 600
    #         cull_busy: false
    #         cull_connected: true

  prePuller:
    hook:
      enabled: true

  ingress:
    enabled: true
    ingressClassName: null
    annotations:
      traefik.ingress.kubernetes.io/router.entrypoints: websecure
      traefik.ingress.kubernetes.io/router.tls: "true"
      #cert-manager.io/cluster-issuer: "letsencrypt" # this issues a certificate for the domain through cert-manager automatically
    hosts:
      # TODO: vre chart value
      - jhub-vre.obsuks4.unige.ch
      - jhub-vre-etap.obsuks4.unige.ch
               
reana:
  enabled: true

  postgres:
    enabled: true

  workspaces:
    retention_rules:
      maximum_period: forever
      cronjob_schedule: "0 2 * * *"  # everyday at 2am
    paths:
      - /var/reana:/var/reana

  shared_storage:
    backend: nfs
    volume_size: 1
    access_modes: ReadWriteMany

  secrets:
    login:
      escape-iam:
        # TODO: set this
        consumer_key: "testkey"
        consumer_secret: "testsecret"

    database:
      user: 
      password:

  components:
    reana_ui:
      enabled: true
      local_users: false
    reana_db:
      enabled: false
    reana_server:
      environment:
        REANA_USER_EMAIL_CONFIRMATION: false
    # reana_workflow_controller:
    #   image: docker.io/mdonadoni/reana-workflow-controller:0.9.1-7e03f0a-cvmfs
    # reana_job_controller:
    #   image: docker.io/reanahub/reana-job-controller-htcondorcern-slurmcern:0.9.1
    reana_workflow_controller:
      imagePullPolicy: IfNotPresent
      image: docker.io/reanahub/reana-workflow-controller:0.9.4
      environment:
        SHARED_VOLUME_PATH: "/var/reana/"
        REANA_JOB_STATUS_CONSUMER_PREFETCH_COUNT: 10


  compute_backends:
    - "kubernetes"
    # - "htcondorcern"
    # - "slurmcern"

  notifications:
    enabled: false
    # email_config:
    #   receiver: escape-cern-ops@cern.ch
    #   sender: escape-cern-ops@cern.ch
    #   login: ""
    #   smtp_server: cernmx.cern.ch
    #   smtp_port: 25

  ingress_override: true

  reana_hostname: "reana-vre.obsuks4.unige.ch"

  db_env_config:
    REANA_DB_NAME: "reana"
    REANA_DB_PORT: "5432"
    REANA_DB_HOST: "postgres-postgresql"
    # There are two more environment variables that should be set in order
    # to connect to a database:
    # REANA_DB_USERNAME: containing the database user name.
    # REANA_DB_PASSWORD: containing the password for the user previously set.
    # Both environment variables should be set inside a Kubernetes secret:
    # `[release-name]-db`

  login:
    - name: "escape-iam"
      type: "keycloak"
      config:
        title: "ESCAPE IAM"
        base_url: "https://iam-escape.cloud.cnaf.infn.it"
        realm_url: "https://iam-escape.cloud.cnaf.infn.it"
        auth_url: "https://iam-escape.cloud.cnaf.infn.it/authorize"
        token_url: "https://iam-escape.cloud.cnaf.infn.it/token"
        userinfo_url: "https://iam-escape.cloud.cnaf.infn.it/userinfo"

  ingress:
    enabled: false

  traefik:
    enabled: false

  quota:
    default_disk_limit: 10737418240  # bytes (10 GiB)
    default_cpu_limit: 36000000      # milliseconds (10 hours)


nfs-server-provisioner:
  enabled: true
  persistence:
    enabled: true
    storageClass: standard
    size: 100M
  storageClass:

    name: cern-vre-shared-volume-storage-class
    # name: reana-infrastructure-volume-storage-class
    mountOptions:
    - tcp
    - nfsvers=4.1
    - retrans=2
    - timeo=30
  tolerations:
  - effect: NoSchedule
    key: CriticalAddonsOnly
    operator: "Exists"
